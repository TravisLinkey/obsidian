
Tags: [[Data Structures & Algorithms]] | [[Array]] | [[Sorting]]


### Overview
This problem gives us an array of integer numbers `nums` and an array `mapping` where each digit `i` should be mapped to digit `j`. Or formally `mapping[i] = j`.

For example:
`mapping = [8,9,4,0,2,1,3,5,7,6], nums = [991,338,38]`

output: `[338,38,991]`

We can see that index = 0 and `mapping[0] = 8`. 

This means `0 -> 8` where `i = 0 and j = 8`.

### Strategy
We know we must loop through every `num` in `nums` and every character in `num`. **O(n)**

Additionally, we will need to sort the mapped results, with highest precedence being the newly mapped value, and second precedence being the original position of the unmapped values.

This means when we have a tie, like `338 -> 007` and `38 -> 07`, we would put `338` first because it appears in the original array `nums` first.

### Explanation
We can be clever and use a form of [[Bitshifting]] by multiplying each digit by 10, to process them from left to right.

Additionally, if we append the mapped values to our `pairs` array as a tuple, we can keep the original position, and applying `.sort()` will take into consideration the index and will sort a tie in the correct order. (pairs that appear first in the original array will come first in the sorted array).

### Code
```python
class Solution:
    def sortJumbled(self, mapping: List[int], nums: List[int]) -> List[int]:
        
        pairs = []
        for i, n in enumerate(nums):
            n = str(n)
            mapping_n = 0

            for c in n:
                mapping_n *= 10   # clever bit shift here, process digits right to left
                mapping_n += mapping[int(c)]

            pairs.append((mapping_n, i))
        pairs.sort()

        return [nums[i] for _, i in pairs]
```


### References
[Leetcode Link]()

